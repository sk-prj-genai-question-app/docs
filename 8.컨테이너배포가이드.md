# 컨테이너화 및 배포 가이드

## 1. 컨테이너 구성

- **Frontend**: React + Nginx
- **Backend**: Spring Boot
- **AI Module**: Python + FastAPI + Uvicorn
- **Database**: MariaDB

## 2. Docker 설정

### 2.1 Frontend Dockerfile

```dockerfile
# Node.js 22.16 버전의 Alpine Linux 기반 이미지를 사용하여 빌드 단계를 정의
# Alpine은 경량화된 Linux 배포판으로 Docker 이미지 크기를 줄이는 데 효과적
FROM node:22.16-alpine AS build

# 컨테이너 내부의 작업 디렉토리를 /app으로 설정
# 이후 모든 명령어는 이 디렉토리에서 실행됨
WORKDIR /app

# Node.js 바이너리들을 PATH에 추가하여 npm, npx 등의 명령어를 쉽게 사용할 수 있도록 설정
# /app/node_modules/.bin 경로를 시스템 PATH 앞부분에 추가
ENV PATH=/app/node_modules/.bin:$PATH

# 호스트의 package.json 파일을 컨테이너의 /app/package.json으로 복사
COPY package.json /app/package.json

# package.json에 정의된 모든 의존성 패키지들을 설치
RUN npm install

# 현재 디렉토리의 모든 파일들(소스 코드)을 컨테이너의 /app 디렉토리로 복사
# .dockerignore 파일이 있다면 해당 파일에 명시된 파일들은 제외됨
COPY . /app

# React 애플리케이션을 프로덕션용으로 빌드
# 일반적으로 dist 또는 build 폴더에 최적화된 정적 파일들이 생성됨
RUN npm run build

# 두 번째 단계: Nginx 웹서버 단계
# 특정 버전의 Nginx 알파인 이미지를 베이스로 사용하여 이미지 크기를 줄이고 일관성을 유지
FROM nginx:1.27-alpine

# Nginx의 기본 설정 파일을 제거
# default.conf는 Nginx가 기본으로 제공하는 설정으로, 커스텀 설정을 사용하기 위해 삭제
RUN rm /etc/nginx/conf.d/default.conf

# 호스트의 nginx/nginx.conf 파일을 컨테이너의 Nginx 설정 디렉토리로 복사
# 이 파일에는 React SPA(Single Page Application)를 위한 커스텀 Nginx 설정이 포함됨
COPY nginx/nginx.conf /etc/nginx/conf.d

# 첫 번째 빌드 단계에서 생성된 React 앱의 빌드 결과물을 Nginx의 정적 파일 서빙 디렉토리로 복사
# --from=build 플래그로 이전 단계의 결과물을 참조
# /app/dist는 빌드된 파일들이 위치한 경로, /usr/share/nginx/html은 Nginx의 기본 웹 루트 디렉토리
COPY --from=build /app/dist /usr/share/nginx/html

# 컨테이너의 80번 포트를 외부에 노출
EXPOSE 80

# nginx를 포그라운드 모드(-g "daemon off;")로 실행하여 컨테이너가 종료되지 않도록 함
# Docker 컨테이너는 메인 프로세스가 종료되면 컨테이너도 함께 종료되므로 daemon off 옵션이 필요
ENTRYPOINT ["nginx", "-g", "daemon off;"]
```

### 2.2 Backend Dockerfile

```dockerfile
# Stage 1: 빌드 환경 설정 (Gradle을 사용하여 JAR 파일 생성)
# Gradle 8.7과 JDK 17이 포함된 Alpine Linux 기반 이미지 사용 (가볍고 효율적)
FROM gradle:8.7-jdk17-alpine AS builder

# 컨테이너 내 작업 디렉토리 설정
WORKDIR /app

# 프로젝트의 모든 파일(소스 코드, build.gradle 등)을 컨테이너의 /app 디렉토리로 복사
# dockerignore 파일이 있다면, 해당 파일에 명시된 내용은 복사되지 않습니다.
COPY . .

# Gradle을 사용하여 프로젝트 빌드
# 'clean build' 명령을 실행하여 프로젝트를 클린하고 빌드합니다.
# GitHub Actions에서 이미 테스트를 수행하므로, 여기서는 -x test 옵션으로 테스트를 제외하여 빌드 시간을 절약합니다.
RUN gradle clean build -x test

# Stage 2: 런타임 환경 설정 (빌드된 JAR 파일을 실행)
# OpenJDK 17의 슬림(slim) 버전 이미지 사용 (필수 런타임만 포함되어 이미지 크기가 작음)
FROM openjdk:17-jdk-slim

# Spring Boot 애플리케이션이 임시 파일을 저장할 수 있도록 /tmp 볼륨을 설정합니다.
# 컨테이너 재시작 시 임시 파일이 사라지도록 하여 컨테이너의 상태를 유지하지 않게 합니다.
VOLUME /tmp

# 빌더 스테이지에서 생성된 JAR 파일을 최종 이미지로 복사합니다.
# 'GenAiQuestionApp-0.0.1-SNAPSHOT.jar' 파일을 'app.jar'라는 이름으로 복사합니다.
# 'app.jar'는 컨테이너 내에서 실행될 애플리케이션의 이름입니다.
COPY --from=builder /app/build/libs/*.jar app.jar

# 컨테이너가 시작될 때 실행될 명령어 정의
# 'java -jar app.jar' 명령으로 Spring Boot 애플리케이션을 실행합니다.
# '--spring.profiles.active=prod'는 Spring 프로파일을 'prod'로 설정하여 프로덕션 환경 설정을 활성화합니다.
ENTRYPOINT ["java", "-jar", "/app.jar", "--spring.profiles.active=prod"]

# 애플리케이션이 사용할 포트를 외부에 노출합니다.
# Spring Boot의 기본 포트는 8080입니다. 애플리케이션 설정에 따라 변경될 수 있습니다.
EXPOSE 8080
# JAR 실행
```

### 2.3 AI Module Dockerfile

```dockerfile
# 1. 베이스 이미지 설정
FROM python:3.12-slim

# 2. 작업 디렉토리 설정
WORKDIR /app

# 3. 시스템 환경 변수 설정 (Python 로그를 바로 확인하기 위함)
ENV PYTHONUNBUFFERED=1

# 4. 의존성 파일 복사 및 설치
# 먼저 의존성만 설치하여, 코드 변경 시 Docker 빌드 캐시를 활용해 빌드 속도를 높입니다.
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 5. 애플리케이션 소스 코드 및 필요 데이터 복사
COPY ./app ./app
COPY ./faiss_index ./faiss_index

# 6. 애플리케이션이 사용할 포트 노출
EXPOSE 8000

# 7. (보안) Non-root 사용자 생성 및 전환
RUN useradd --create-home appuser
USER appuser

# 8. 애플리케이션 실행
# Uvicorn을 사용하여 0.0.0.0 호스트에서 앱을 실행해야 Docker 컨테이너 외부에서 접근 가능합니다.
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

```

## 3. Docker Compose

```yaml
version: '3.8'
services:
  database:
    image: mariadb:10.11

  ai-service:
    build: ./ai-module

  backend:
    build: ./backend
    depends_on:
      - database
      - ai-service

  frontend:
    build: ./frontend
    depends_on:
      - backend
```

## 4. 환경 변수

### 4.1 개발 환경

```env
DB_HOST=localhost
DB_USER=dev_user
AI_SERVICE_URL=http://ai-service:8000
```

### 4.2 운영 환경

```env
DB_HOST=prod-db
OPENAI_API_KEY=${SECURE_KEY}
```

## 5. 클라우드 배포

### 5.1 AWS EC2

```bash
# 배포 스크립트
docker-compose up -d
```

### 5.2 GCP GKE

```yaml
# Kubernetes 매니페스트
apiVersion: apps/v1
kind: Deployment
```

## 6. CI/CD

```yaml
# GitHub Actions
name: Deploy
on:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
```

## 7. 네트워크

- Frontend: 포트 5173
- Backend: 포트 8080
- AI Module: 포트 8000
- Database: 포트 3306

## 8. 완료 체크리스트

- [ ] Docker 이미지 빌드
- [ ] 컨테이너 실행
- [ ] 네트워크 연결 확인
- [ ] 헬스체크 통과
- [ ] 클라우드 배포
